# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' getBinaryREH()
#'
#' @param dyad vector of dyad occurred (reh$edgelist[,2])
#' @param D numbr of possible dyads (reh$D)
#'
#' @return matrix with dimensions given by the number of events (by row) and the dimension of the risk set (by column) .
#'
#' @export
getBinaryREH <- function(dyad, D) {
    .Call('_bremory_getBinaryREH', PACKAGE = 'bremory', dyad, D)
}

#' getIntervals
#'
#' given vectors of widths and time, the function returns.
#'
#' @param env  is the global environment
#' @param widths time lengths of intervals as to the stepwise model
#' @param time vector of time points
#' @param M number of events
#' @param K_q number of steps for the q-th model
#' @param nthreads number of threads
#'
#' @return matrix.
#'
#' @export
getIntervals <- function(env, widths, time, M, K_q, nthreads) {
    invisible(.Call('_bremory_getIntervals', PACKAGE = 'bremory', env, widths, time, M, K_q, nthreads))
}

#' getCountsOMP
#'
#' @param binaryREH matrix
#' @param lbs_ubs matrix of lower bounds (lb's, first column) and upper bounds (ub's, second column) of binaryREH
#' @param nthreads nthreads
#'
#' @return matrix of accumulated counts within ranges of binaryREH
#'
#' @export
getCountsOMP <- function(binaryREH, lbs_ubs, nthreads) {
    .Call('_bremory_getCountsOMP', PACKAGE = 'bremory', binaryREH, lbs_ubs, nthreads)
}

#' getCountsIndex (function useful for statistics computation)
#'
#' @param intervals matrix of intervals (non-unique intervals, first two columns are lower bound and upper bound respectively)
#' @param counts matrix of intervals (first two columns are lower bound and upper bound respectively)
#' @param nthreads number of threads
#'
#' @return vector of row indices relative to the matrix 'counts'
#'
#' @export
getCountsIndex <- function(intervals, counts, nthreads) {
    .Call('_bremory_getCountsIndex', PACKAGE = 'bremory', intervals, counts, nthreads)
}

#' getEndoEffects
#'
#' @param env environment where the user is currently working (usually the global one which can be accessed via 'globalenv()' function or '.GlobalEnv' object)
#' @param M number of events
#' @param D number of dyads
#' @param time vector of time points
#' @param edgelist matrix of [time,actor1,actor2,type,weigth]
#' @param risksetMatrix risksetMatrix object inside 'reh' object
#' @param risksetCube0 risksetCube[,,1] object inside 'reh' object. We only consider one event type for now
#' @param nthreads number of threads to create in case of parallelization
#'
#' @return array of Statistics specified in the
#'
#' @export
getEndoEffects <- function(env, M, D, time, edgelist, risksetMatrix, risksetCube0, nthreads) {
    .Call('_bremory_getEndoEffects', PACKAGE = 'bremory', env, M, D, time, edgelist, risksetMatrix, risksetCube0, nthreads)
}

#' lpd (Log-Pointwise Density of REM)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
lpd <- function(pars, stats, event, interevent_time) {
    .Call('_bremory_lpd', PACKAGE = 'bremory', pars, stats, event, interevent_time)
}

#' getWAIC
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
getWAIC <- function(pars, stats, events, interevent_time) {
    .Call('_bremory_getWAIC', PACKAGE = 'bremory', pars, stats, events, interevent_time)
}

#' smoothing posterior.
#'
#' This function calculates the posterior distribution give...
#'
#' @param sample_models sample_models
#' @param knots_seq knots_seq
#' @param which_pars which_pars
#' @param post_betas post_betas
#' @param post_gammas post_gammas
#' @param U n_pars
#'
#' @return a cube of posterior draws.
#'
#' @export
smoothing_posterior <- function(sample_models, knots_seq, which_pars, post_betas, post_gammas, U) {
    .Call('_bremory_smoothing_posterior', PACKAGE = 'bremory', sample_models, knots_seq, which_pars, post_betas, post_gammas, U)
}

#' getDraws
#'
#' Function to draw from the posterior distribution (here the second step of drawing from Normal distribution is performed;
#' the first consists in drawing from the multinomial distribution for the Q models)
#'
#' @param sample_models models sample with probabilities given by the specific weighting system used (BIC, pseudoBMA+, stacking, WAIC)
#' @param which_pars which parameters
#' @param n_pars number of parameters per model in the set
#' @param n_stats number of statistics
#' @param input list() of K (number of intervals), gammas (time widths), mle_betas (Maximum Likelihood Estimates), vcov_betas (variance and covariance matrix)
#' @param knots_seq sequence of time widths at which compute the posterior distribution
#'
#' @return matrix.
#'
#' @export
getDraws <- function(sample_models, which_pars, n_pars, n_stats, input, knots_seq) {
    .Call('_bremory_getDraws', PACKAGE = 'bremory', sample_models, which_pars, n_pars, n_stats, input, knots_seq)
}

#' tryClone (text here)
#'
#' @param input description of input here
#'
#' @return input [dataframe]
#'
#' @export
tryClone <- function(input) {
    .Call('_bremory_tryClone', PACKAGE = 'bremory', input)
}

