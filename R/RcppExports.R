# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' getRiskset (obtain permutations of actors' id).
#'
#' @param actors vector of actors' id's (either integer or char vector).
#' @param N number of actors in the network.
#' @param selfedges if selfedges are allowed (TRUE) or not (FALSE).
#'
#' @return matrix of possible dyadic events.
#'
#' @export
getRiskset <- function(actors_id, N, selfedges) {
    .Call('_bremory_getRiskset', PACKAGE = 'bremory', actors_id, N, selfedges)
}

#' getRisksetMatrix
#'
#' @param riskset matrix (sender and receiver integer id's by column)
#' @param N number of actors in the network.
#'
#' @return matrix of possible dyadic events arranged in a square matrx (cell value is the row index of the riskset matrix input, which will be the same to the column index in binary REH).
#'
#' @export
getRisksetMatrix <- function(riskset, N) {
    .Call('_bremory_getRisksetMatrix', PACKAGE = 'bremory', riskset, N)
}

#' getBinaryREH()
#'
#'
#' @param M number of relational events observed
#' @param N number of actors
#' @param edgelist matrix of (time,sender,receiver)
#' @param riskset_matrix matrix of possible dyadic events with column_order per each cell (this will be the order in the binaryREH matrices columns)
#'
#' @return Matrix with dimensions given by the number of events (by row) and the dimension of the risk set (by column) .
#'
#' @export
getBinaryREH <- function(M, N, edgelist, riskset_matrix) {
    .Call('_bremory_getBinaryREH', PACKAGE = 'bremory', M, N, edgelist, riskset_matrix)
}

#' getIntervals
#'
#' given vectors of widths and time, the function returns.
#'
#' @param env  is the global environment
#' @param widths time lengths of intervals as to the stepwise model
#'
#' @return matrix.
#'
#' @export
getIntervals <- function(env, widths) {
    invisible(.Call('_bremory_getIntervals', PACKAGE = 'bremory', env, widths))
}

#' getCountsOMP
#'
#' @param binaryREH matrix
#' @param lbs_ubs matrix of lower bounds (lb's, first column) and upper bounds (ub's, second column) of binaryREH
#' @param n_cores n_cores
#'
#' @return matrix of accumulated counts within ranges of binaryREH
#'
#' @export
getCountsOMP <- function(binaryREH, lbs_ubs, n_cores) {
    .Call('_bremory_getCountsOMP', PACKAGE = 'bremory', binaryREH, lbs_ubs, n_cores)
}

#' getCountsIndex (function useful for statistics computation)
#'
#' @param intervals matrix of intervals (non-unique intervals, first two columns are lower bound and upper bound respectively)
#' @param counts matrix of intervals (first two columns are lower bound and upper bound respectively)
#'
#' @return vector of row indices relative to the matrix 'counts'
#'
#' @export
getCountsIndex <- function(intervals, counts) {
    .Call('_bremory_getCountsIndex', PACKAGE = 'bremory', intervals, counts)
}

#' getEndoEffects
#'
#' @param env environment where the user is currently working (usually the global one which can be accessed via 'globalenv()' function or '.GlobalEnv' object)
#'
#' @return array of Statistics specified in the
#'
#' @export
getEndoEffects <- function(env) {
    .Call('_bremory_getEndoEffects', PACKAGE = 'bremory', env)
}

#' lpd (Log-Pointwise Density of REM)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
lpd <- function(pars, stats, event, interevent_time) {
    .Call('_bremory_lpd', PACKAGE = 'bremory', pars, stats, event, interevent_time)
}

#' getWAIC
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
getWAIC <- function(pars, stats, events, interevent_time) {
    .Call('_bremory_getWAIC', PACKAGE = 'bremory', pars, stats, events, interevent_time)
}

#' lpdWAIC
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
lpdWAIC <- function(pars, stats, events, interevent_time) {
    .Call('_bremory_lpdWAIC', PACKAGE = 'bremory', pars, stats, events, interevent_time)
}

#' logpJi 
#'
#' @param pars is a matrix of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return vector of log-pointwise density values of a specific time point at different parameters values
#'
#' @export
logpJi <- function(pars, stats, event, interevent_time) {
    .Call('_bremory_logpJi', PACKAGE = 'bremory', pars, stats, event, interevent_time)
}

#' smoothing posterior.
#'
#' This function calculates the posterior distribution give...
#'
#' @param sample_models sample_models
#' @param knots_seq knots_seq
#' @param which_pars which_pars
#' @param post_betas post_betas
#' @param post_gammas post_gammas
#' @param n_pars n_pars
#'
#' @return a cube of posterior draws.
#'
#' @export
smoothing_posterior <- function(sample_models, knots_seq, which_pars, post_betas, post_gammas, U) {
    .Call('_bremory_smoothing_posterior', PACKAGE = 'bremory', sample_models, knots_seq, which_pars, post_betas, post_gammas, U)
}

#' getDraws
#'
#' Function to draw from the posterior distribution (here the second step of drawing from Normal distribution is performed;
#' the first consists in drawing from the multinomial distribution for the Q models)
#'
#' @param sample_models models sample with probabilities given by the specific weighting system used (BIC, pseudoBMA+, stacking, WAIC)
#' @param which_pars which parameters
#' @param n_pars number of parameters per model in the set
#' @param n_stats number of statistics
#' @param input list() of K (number of intervals), gammas (time widths), mle_betas (Maximum Likelihood Estimates), vcov_betas (variance and covariance matrix)
#' @param knots_seq sequence of time widths at which compute the posterior distribution
#'
#' @return matrix.
#'
#' @export
getDraws <- function(sample_models, which_pars, n_pars, n_stats, input, knots_seq) {
    .Call('_bremory_getDraws', PACKAGE = 'bremory', sample_models, which_pars, n_pars, n_stats, input, knots_seq)
}

#' updateEndoEffects 
#'
#'
#' @param effects string vector of endogenous effects to calculate
#' @param beta_endo list of parameters per each effect (the order must follow the one of the vector 'effects')
#' @param binaryREH binary Relational Event History until event at t(M_partial)
#' @param elapsed_time vector of elapsed times since each past event until t(M_partial)
#' @param edgelist edgelist (partial edgelist until M_partial)
#' @param riskset matrix of (sender,receiver) combinations in the case of no selfedges
#' @param riskset_matrix square matrix where the (row,colum)=(sender,receiver) returns the corresponding column index in the matrix binaryREH_partial
#' @param N number of actors
#' @param M_partial partial event sequence length
#'
#' @return matrix of statistics per dyad (where a continuous effect decay for each statistics was specified)
#' 
#' @export
updateEndoEffects <- function(effects, beta_endo, binaryREH, elapsed_time, edgelist, riskset, riskset_matrix, N, M_partial) {
    .Call('_bremory_updateEndoEffects', PACKAGE = 'bremory', effects, beta_endo, binaryREH, elapsed_time, edgelist, riskset, riskset_matrix, N, M_partial)
}

#' stepwise 
#'
#' @param x transpired time
#' @param pars is the matrix of (betas,widths)
#'
#' @export
stepwiseWeight <- function(x, pars) {
    .Call('_bremory_stepwiseWeight', PACKAGE = 'bremory', x, pars)
}

#' linearWeight 
#'
#' @param x transpired time
#' @param pars is the vector with order (alpha,psi) with alpha in (0,Inf) and psi in (0,Inf) 
#'
#' @export
linearWeight <- function(x, pars) {
    .Call('_bremory_linearWeight', PACKAGE = 'bremory', x, pars)
}

#' twoStepsWeight 
#'
#' @param x transpired time
#' @param pars is the vector of parameters OLD=(shape,scale,psi,phi,shape,scale), (shape1,scale1,psi,phi,x0,shape2,scale2)
#'
#' @export
twoStepsWeight <- function(x, pars) {
    .Call('_bremory_twoStepsWeight', PACKAGE = 'bremory', x, pars)
}

#' weibullWeight (it can be either exponential of a smoothed single-step decrease)
#'
#' @param x transpired time
#' @param pars is the vector with order (shape, scale, psi) 
#'
#' @export
weibullWeight <- function(x, pars) {
    .Call('_bremory_weibullWeight', PACKAGE = 'bremory', x, pars)
}

#' decay (function that calculates the decay according)
#'
#' @param type string defining the type of decay
#' @param x elapsed time of interest
#' @param pars is the vector with order 
#'
#' @export
decay <- function(type, x, pars) {
    .Call('_bremory_decay', PACKAGE = 'bremory', type, x, pars)
}

