# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' getBinaryREH()
#'
#'
#' @param M number of relational events observed
#' @param N number of actors
#' @param edgelist matrix of (time,sender,receiver)
#' @param riskset_matrix matrix of possible dyadic events with column_order per each cell (this will be the order in the binaryREH matrices columns)
#'
#' @return Matrix with dimensions given by the number of events (by row) and the dimension of the risk set (by column) .
#'
#' @export
getBinaryREH <- function(M, N, edgelist, riskset_matrix) {
    .Call('_bremory_getBinaryREH', PACKAGE = 'bremory', M, N, edgelist, riskset_matrix)
}

#' getIntervals
#'
#' given vectors of widths and time, the function returns.
#'
#' @param env  is the global environment
#' @param widths time lengths of intervals as to the stepwise model
#'
#' @return matrix.
#'
#' @export
getIntervals <- function(env, widths) {
    invisible(.Call('_bremory_getIntervals', PACKAGE = 'bremory', env, widths))
}

#' getCountsOMP
#'
#' @param binaryREH matrix
#' @param lbs_ubs matrix of lower bounds (lb's, first column) and upper bounds (ub's, second column) of binaryREH
#' @param n_threads n_threads
#'
#' @return matrix of accumulated counts within ranges of binaryREH
#'
#' @export
getCountsOMP <- function(binaryREH, lbs_ubs, n_threads) {
    .Call('_bremory_getCountsOMP', PACKAGE = 'bremory', binaryREH, lbs_ubs, n_threads)
}

#' getCountsIndex (function useful for statistics computation)
#'
#' @param intervals matrix of intervals (non-unique intervals, first two columns are lower bound and upper bound respectively)
#' @param counts matrix of intervals (first two columns are lower bound and upper bound respectively)
#'
#' @return vector of row indices relative to the matrix 'counts'
#'
#' @export
getCountsIndex <- function(intervals, counts) {
    .Call('_bremory_getCountsIndex', PACKAGE = 'bremory', intervals, counts)
}

#' getEndoEffects
#'
#' @param env environment where the user is currently working (usually the global one which can be accessed via 'globalenv()' function or '.GlobalEnv' object)
#'
#' @return array of Statistics specified in the
#'
#' @export
getEndoEffects <- function(env) {
    .Call('_bremory_getEndoEffects', PACKAGE = 'bremory', env)
}

#' getEndoEffects_old
#'
#' @param env environment where the user is currently working (usually the global one which can be accessed via 'globalenv()' function or '.GlobalEnv' object)
#'
#' @return array of Statistics specified in the
#'
#' @export
getEndoEffects_old <- function(env) {
    .Call('_bremory_getEndoEffects_old', PACKAGE = 'bremory', env)
}

#' getSmoothEndoEffects
#'
#' @param env environment where the user is currently working (usually the global one which can be accessed via 'globalenv()' function or '.GlobalEnv' object)
#' @param endo_effects string vector indicating the endogenous effects
#' @param decay_fun function for the decay of past events influence
#' @param pars matrix with parameters for the decay_fun
#' @param n_threads number of corse to be used in the parallelization
#'
#' @return array of Statistics specified 
#'
#' @export
getSmoothEndoEffects <- function(reh, endo_effects, endo_memory_pars, n_threads) {
    .Call('_bremory_getSmoothEndoEffects', PACKAGE = 'bremory', reh, endo_effects, endo_memory_pars, n_threads)
}

#' lpd (Log-Pointwise Density of REM)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
lpd <- function(pars, stats, event, interevent_time) {
    .Call('_bremory_lpd', PACKAGE = 'bremory', pars, stats, event, interevent_time)
}

#' nllik (negative log-likelihood rem model)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a cube of dimensions n_dyads*variables*M with statistics of interest by column and dyads by row.
#' @param event_binary is a matrix of ones and zeros of dimensions M*n_dyads : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the vector of time differences between the current time point and the previous event time.
#' @param n_threads n_threads
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
nllik <- function(pars, stats, event_binary, interevent_time, n_threads) {
    .Call('_bremory_nllik', PACKAGE = 'bremory', pars, stats, event_binary, interevent_time, n_threads)
}

#' performBSIR
#' 
#' A function that performs the BSIR on the REM model
#'
#' @param nsim number of simulations
#' @param mean vector of model MLEs
#' @param sigma matric of variances and covariances 
#' @param df degrees of freedom for the multivariate Student t (used as proposal distribution)
#' @param stats cube of statistics [D*P*M]
#' @param event_binary matrix of 1/0
#' @param interevent_time vector of interevent times
#' @param n_threads number of cores to be used in the parallelized calculation of the nllik()
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
performBSIR <- function(nsim, mean, sigma, df, stats, event_binary, interevent_time, n_threads) {
    .Call('_bremory_performBSIR', PACKAGE = 'bremory', nsim, mean, sigma, df, stats, event_binary, interevent_time, n_threads)
}

#' getWAIC
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
getWAIC <- function(pars, stats, events, interevent_time) {
    .Call('_bremory_getWAIC', PACKAGE = 'bremory', pars, stats, events, interevent_time)
}

#' lpdWAIC
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
lpdWAIC <- function(pars, stats, events, interevent_time) {
    .Call('_bremory_lpdWAIC', PACKAGE = 'bremory', pars, stats, events, interevent_time)
}

#' logpJi 
#'
#' @param pars is a matrix of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return vector of log-pointwise density values of a specific time point at different parameters values
#'
#' @export
logpJi <- function(pars, stats, event, interevent_time) {
    .Call('_bremory_logpJi', PACKAGE = 'bremory', pars, stats, event, interevent_time)
}

#' smoothing posterior.
#'
#' This function calculates the posterior distribution give...
#'
#' @param sample_models sample_models
#' @param knots_seq knots_seq
#' @param which_pars which_pars
#' @param post_betas post_betas
#' @param post_gammas post_gammas
#' @param n_pars n_pars
#'
#' @return a cube of posterior draws.
#'
#' @export
smoothing_posterior <- function(sample_models, knots_seq, which_pars, post_betas, post_gammas, U) {
    .Call('_bremory_smoothing_posterior', PACKAGE = 'bremory', sample_models, knots_seq, which_pars, post_betas, post_gammas, U)
}

#' getDraws
#'
#' Function to draw from the posterior distribution (here the second step of drawing from Normal distribution is performed;
#' the first consists in drawing from the multinomial distribution for the Q models)
#'
#' @param sample_models models sample with probabilities given by the specific weighting system used (BIC, pseudoBMA+, stacking, WAIC)
#' @param which_pars which parameters
#' @param n_pars number of parameters per model in the set
#' @param n_stats number of statistics
#' @param input list() of K (number of intervals), gammas (time widths), mle_betas (Maximum Likelihood Estimates), vcov_betas (variance and covariance matrix)
#' @param knots_seq sequence of time widths at which compute the posterior distribution
#'
#' @return matrix.
#'
#' @export
getDraws <- function(sample_models, which_pars, n_pars, n_stats, input, knots_seq) {
    .Call('_bremory_getDraws', PACKAGE = 'bremory', sample_models, which_pars, n_pars, n_stats, input, knots_seq)
}

#' tryClone
#'
#' @param input data.frame object
#'
#' @return input [dataframe]
#'
#' @export
tryClone <- function(input) {
    .Call('_bremory_tryClone', PACKAGE = 'bremory', input)
}

#' getRiskset_old (obtain permutations of actors' id). (will become getRisksetMatrix) 
#'
#' @param actors vector of actors' id's (either integer or char vector).
#' @param N number of actors in the network.
#' @param selfedges if selfedges are allowed (TRUE) or not (FALSE).
#'
#' @return matrix of possible dyadic events.
#'
#' @export
getRiskset_old <- function(actors_id, N, selfedges) {
    .Call('_bremory_getRiskset_old', PACKAGE = 'bremory', actors_id, N, selfedges)
}

#' getRisksetMatrix_old 
#'
#' @param riskset matrix (sender and receiver integer id's by column)
#' @param N number of actors in the network.
#'
#' @return matrix of possible dyadic events arranged in a square matrx (cell value is the row index of the riskset matrix input, which will be the same to the column index in binary REH).
#'
#' @export
getRisksetMatrix_old <- function(riskset, N) {
    .Call('_bremory_getRisksetMatrix_old', PACKAGE = 'bremory', riskset, N)
}

#' getBinaryREH_old
#'
#'
#' @param M number of relational events observed
#' @param N number of actors
#' @param edgelist matrix of (time,sender,receiver)
#' @param riskset_matrix matrix of possible dyadic events with column_order per each cell (this will be the order in the binaryREH matrices columns)
#'
#' @return Matrix with dimensions given by the number of events (by row) and the dimension of the risk set (by column) .
#'
#' @export
getBinaryREH_old <- function(M, N, edgelist, riskset_matrix) {
    .Call('_bremory_getBinaryREH_old', PACKAGE = 'bremory', M, N, edgelist, riskset_matrix)
}

#' getIntervals_old
#'
#' given vectors of widths and time, the function returns.
#'
#' @param env  is the global environment
#' @param widths time lengths of intervals as to the stepwise model
#'
#' @return matrix.
#'
#' @export
getIntervals_old <- function(env, widths) {
    invisible(.Call('_bremory_getIntervals_old', PACKAGE = 'bremory', env, widths))
}

#' getCountsOMP_old
#'
#' @param binaryREH matrix
#' @param lbs_ubs matrix of lower bounds (lb's, first column) and upper bounds (ub's, second column) of binaryREH
#' @param n_cores n_cores
#'
#' @return matrix of accumulated counts within ranges of binaryREH
#'
#' @export
getCountsOMP_old <- function(binaryREH, lbs_ubs, n_cores) {
    .Call('_bremory_getCountsOMP_old', PACKAGE = 'bremory', binaryREH, lbs_ubs, n_cores)
}

#' getCountsIndex_old (function useful for statistics computation)
#'
#' @param intervals matrix of intervals (non-unique intervals, first two columns are lower bound and upper bound respectively)
#' @param counts matrix of intervals (first two columns are lower bound and upper bound respectively)
#'
#' @return vector of row indices relative to the matrix 'counts'
#'
#' @export
getCountsIndex_old <- function(intervals, counts) {
    .Call('_bremory_getCountsIndex_old', PACKAGE = 'bremory', intervals, counts)
}

#' lpd_old (Log-Pointwise Density of REM)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
lpd_old <- function(pars, stats, event, interevent_time) {
    .Call('_bremory_lpd_old', PACKAGE = 'bremory', pars, stats, event, interevent_time)
}

#' nllik_old (negative log-likelihood rem model)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a cube of dimensions n_dyads*variables*M with statistics of interest by column and dyads by row.
#' @param event_binary is a matrix of ones and zeros of dimensions M*n_dyads : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the vector of time differences between the current time point and the previous event time.
#' @param n_cores n_cores
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
nllik_old <- function(pars, stats, event_binary, interevent_time, n_cores) {
    .Call('_bremory_nllik_old', PACKAGE = 'bremory', pars, stats, event_binary, interevent_time, n_cores)
}

#' performBSIR_old
#' 
#' A function that performs the BSIR on the REM model
#'
#' @param nsim number of simulations
#' @param mean vector of model MLEs
#' @param sigma matric of variances and covariances 
#' @param df degrees of freedom for the multivariate Student t (used as proposal distribution)
#' @param stats cube of statistics [D*P*M]
#' @param event_binary matrix of 1/0
#' @param interevent_time vector of interevent times
#' @param n_cores number of cores to be used in the parallelized calculation of the nllik()
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
performBSIR_old <- function(nsim, mean, sigma, df, stats, event_binary, interevent_time, n_cores) {
    .Call('_bremory_performBSIR_old', PACKAGE = 'bremory', nsim, mean, sigma, df, stats, event_binary, interevent_time, n_cores)
}

#' getWAIC_old
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
getWAIC_old <- function(pars, stats, events, interevent_time) {
    .Call('_bremory_getWAIC_old', PACKAGE = 'bremory', pars, stats, events, interevent_time)
}

#' lpdWAIC_old
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
lpdWAIC_old <- function(pars, stats, events, interevent_time) {
    .Call('_bremory_lpdWAIC_old', PACKAGE = 'bremory', pars, stats, events, interevent_time)
}

#' logpJi_old
#'
#' @param pars is a matrix of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return vector of log-pointwise density values of a specific time point at different parameters values
#'
#' @export
logpJi_old <- function(pars, stats, event, interevent_time) {
    .Call('_bremory_logpJi_old', PACKAGE = 'bremory', pars, stats, event, interevent_time)
}

#' smoothing posterior_old
#'
#' This function calculates the posterior distribution give...
#'
#' @param sample_models sample_models
#' @param knots_seq knots_seq
#' @param which_pars which_pars
#' @param post_betas post_betas
#' @param post_gammas post_gammas
#' @param n_pars n_pars
#'
#' @return a cube of posterior draws.
#'
#' @export
smoothing_posterior_old <- function(sample_models, knots_seq, which_pars, post_betas, post_gammas, U) {
    .Call('_bremory_smoothing_posterior_old', PACKAGE = 'bremory', sample_models, knots_seq, which_pars, post_betas, post_gammas, U)
}

#' getDraws_old
#'
#' Function to draw from the posterior distribution (here the second step of drawing from Normal distribution is performed;
#' the first consists in drawing from the multinomial distribution for the Q models)
#'
#' @param sample_models models sample with probabilities given by the specific weighting system used (BIC, pseudoBMA+, stacking, WAIC)
#' @param which_pars which parameters
#' @param n_pars number of parameters per model in the set
#' @param n_stats number of statistics
#' @param input list() of K (number of intervals), gammas (time widths), mle_betas (Maximum Likelihood Estimates), vcov_betas (variance and covariance matrix)
#' @param knots_seq sequence of time widths at which compute the posterior distribution
#'
#' @return matrix.
#'
#' @export
getDraws_old <- function(sample_models, which_pars, n_pars, n_stats, input, knots_seq) {
    .Call('_bremory_getDraws_old', PACKAGE = 'bremory', sample_models, which_pars, n_pars, n_stats, input, knots_seq)
}

#' tryClone_old
#'
#' @param input data.frame object
#'
#' @return input [dataframe]
#'
#' @export
tryClone_old <- function(input) {
    .Call('_bremory_tryClone_old', PACKAGE = 'bremory', input)
}

#' stepwise 
#'
#' @param x transpired time
#' @param pars is the matrix of (betas,widths)
#'
#' @export
stepwiseWeight <- function(x, pars) {
    .Call('_bremory_stepwiseWeight', PACKAGE = 'bremory', x, pars)
}

#' linearWeight 
#'
#' @param x transpired time
#' @param pars is the vector with order (alpha,psi) with alpha in (0,Inf) and psi in (0,Inf) 
#'
#' @export
linearWeight <- function(x, pars) {
    .Call('_bremory_linearWeight', PACKAGE = 'bremory', x, pars)
}

#' twoStepsWeight 
#'
#' @param x transpired time
#' @param pars is the vector of parameters OLD=(shape,scale,psi,phi,shape,scale), (shape1,scale1,psi,phi,x0,shape2,scale2)
#'
#' @export
twoStepsWeight <- function(x, pars) {
    .Call('_bremory_twoStepsWeight', PACKAGE = 'bremory', x, pars)
}

#' weibullWeight (it can be either exponential of a smoothed single-step decrease)
#'
#' @param x transpired time
#' @param pars is the vector with order (shape, scale, psi) 
#'
#' @export
weibullWeight <- function(x, pars) {
    .Call('_bremory_weibullWeight', PACKAGE = 'bremory', x, pars)
}

#' halflifeWeight
#'
#' @param x transpired time
#' @param pars is a column vector with the halflife
#'
#' @export
halflifeWeight <- function(x, pars) {
    .Call('_bremory_halflifeWeight', PACKAGE = 'bremory', x, pars)
}

#' tmaxWeight
#'
#' @param x transpired time
#' @param pars is the matrix of dim 1x1 with the time threshold
#'
#' @export
tmaxWeight <- function(x, pars) {
    .Call('_bremory_tmaxWeight', PACKAGE = 'bremory', x, pars)
}

#' decay (function that calculates the decay according)
#'
#' @param type string defining the type of decay
#' @param x elapsed time of interest
#' @param pars is the vector with order 
#'
#' @export
decay <- function(type, x, pars) {
    .Call('_bremory_decay', PACKAGE = 'bremory', type, x, pars)
}

