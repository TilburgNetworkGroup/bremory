# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' smmInertia()
#'
#'
#' @param vuoto 
#' 
#' @return vuoto
#'
#' @export
smmInertia <- function() {
    .Call('_bremory_smmInertia', PACKAGE = 'bremory')
}

#' pmmInertia()
#'
#'
#' @param vuoto 
#' 
#' @return vuoto
#'
#' @export
pmmInertia <- function() {
    .Call('_bremory_pmmInertia', PACKAGE = 'bremory')
}

#' pmmDecay()
#'
#'
#' @param vuoto 
#' 
#' @return vuoto
#'
#' @export
pmmDecay <- function() {
    .Call('_bremory_pmmDecay', PACKAGE = 'bremory')
}

#' getBinaryREH()
#'
#' @param dyad vector of dyad occurred (reh$edgelist[,2])
#' @param D numbr of possible dyads (reh$D)
#'
#' @return matrix with dimensions given by the number of events (by row) and the dimension of the risk set (by column) .
#'
#' @export
getBinaryREH <- function(dyad, D) {
    .Call('_bremory_getBinaryREH', PACKAGE = 'bremory', dyad, D)
}

#' convertToReleventEdgelist()
#'
#'
#' @param edgelist input edgelist from 'reh' object
#'
#' @return data.frame
#'
#' @export
convertToReleventEdgelist <- function(reh) {
    .Call('_bremory_convertToReleventEdgelist', PACKAGE = 'bremory', reh)
}

#' getIntervals
#'
#' given vectors of widths and time, the function returns.
#'
#' @param env  is the global environment
#' @param widths time lengths of intervals as to the stepwise model
#' @param time vector of time points
#' @param M number of events
#' @param K_q number of steps for the q-th model
#' @param nthreads number of threads
#'
#' @return matrix.
#'
#' @export
getIntervals <- function(env, widths, time, M, K_q, nthreads) {
    invisible(.Call('_bremory_getIntervals', PACKAGE = 'bremory', env, widths, time, M, K_q, nthreads))
}

#' getCountsOMP
#'
#' @param binaryREH matrix
#' @param lbs_ubs matrix of lower bounds (lb's, first column) and upper bounds (ub's, second column) of binaryREH
#' @param nthreads nthreads
#'
#' @return matrix of accumulated counts within ranges of binaryREH
#'
#' @export
getCountsOMP <- function(binaryREH, lbs_ubs, nthreads) {
    .Call('_bremory_getCountsOMP', PACKAGE = 'bremory', binaryREH, lbs_ubs, nthreads)
}

#' getCountsIndex (function useful for statistics computation)
#'
#' @param intervals matrix of intervals (non-unique intervals, first two columns are lower bound and upper bound respectively)
#' @param counts matrix of intervals (first two columns are lower bound and upper bound respectively)
#' @param nthreads number of threads
#'
#' @return vector of row indices relative to the matrix 'counts'
#'
#' @export
getCountsIndex <- function(intervals, counts, nthreads) {
    .Call('_bremory_getCountsIndex', PACKAGE = 'bremory', intervals, counts, nthreads)
}

#' getEndoEffects
#'
#' @param env environment where the user is currently working (usually the global one which can be accessed via 'globalenv()' function or '.GlobalEnv' object)
#' @param M number of events
#' @param D number of dyads
#' @param time vector of time points
#' @param edgelist matrix of [time,actor1,actor2,type,weigth]
#' @param risksetMatrix risksetMatrix object inside 'reh' object
#' @param risksetCube0 risksetCube[,,1] object inside 'reh' object. We only consider one event type for now
#' @param nthreads number of threads to create in case of parallelization
#'
#' @return array of Statistics specified in the
#'
#' @export
getEndoEffects <- function(env, M, D, time, edgelist, risksetMatrix, risksetCube0, nthreads) {
    .Call('_bremory_getEndoEffects', PACKAGE = 'bremory', env, M, D, time, edgelist, risksetMatrix, risksetCube0, nthreads)
}

#' getSmoothEndoEffects
#'
#' @param reh "reh" object
#' @param endo_effects string vector indicating the endogenous effects
#' @param endo_memory_pars function for the decay of past events influence
#' @param nthreads number of corse to be used in the parallelization
#'
#' @return array of Statistics specified 
#'
#' @export
getSmoothEndoEffects <- function(reh, endo_effects, endo_memory_pars, nthreads) {
    .Call('_bremory_getSmoothEndoEffects', PACKAGE = 'bremory', reh, endo_effects, endo_memory_pars, nthreads)
}

#' lpd (Log-Pointwise Density of REM)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
lpd <- function(pars, stats, event, interevent_time) {
    .Call('_bremory_lpd', PACKAGE = 'bremory', pars, stats, event, interevent_time)
}

#' nllik (negative log-likelihood rem model)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a cube of dimensions n_dyads*variables*M with statistics of interest by column and dyads by row.
#' @param event_binary is a matrix of ones and zeros of dimensions M*n_dyads : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the vector of time differences between the current time point and the previous event time.
#' @param nthreads nthreads
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
nllik <- function(pars, stats, event_binary, interevent_time, nthreads) {
    .Call('_bremory_nllik', PACKAGE = 'bremory', pars, stats, event_binary, interevent_time, nthreads)
}

#' performBSIR
#' 
#' A function that performs the BSIR on the REM model
#'
#' @param nsim number of simulations
#' @param mean vector of model MLEs
#' @param sigma matric of variances and covariances 
#' @param df degrees of freedom for the multivariate Student t (used as proposal distribution)
#' @param stats cube of statistics [D*P*M]
#' @param event_binary matrix of 1/0
#' @param interevent_time vector of interevent times
#' @param nthreads number of cores to be used in the parallelized calculation of the nllik()
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
performBSIR <- function(nsim, mean, sigma, df, stats, event_binary, interevent_time, nthreads) {
    .Call('_bremory_performBSIR', PACKAGE = 'bremory', nsim, mean, sigma, df, stats, event_binary, interevent_time, nthreads)
}

#' getWAIC
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
getWAIC <- function(pars, stats, events, interevent_time) {
    .Call('_bremory_getWAIC', PACKAGE = 'bremory', pars, stats, events, interevent_time)
}

#' lpdWAIC
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
lpdWAIC <- function(pars, stats, events, interevent_time) {
    .Call('_bremory_lpdWAIC', PACKAGE = 'bremory', pars, stats, events, interevent_time)
}

#' logpJi 
#'
#' @param pars is a matrix of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return vector of log-pointwise density values of a specific time point at different parameters values
#'
#' @export
logpJi <- function(pars, stats, event, interevent_time) {
    .Call('_bremory_logpJi', PACKAGE = 'bremory', pars, stats, event, interevent_time)
}

#' smoothing posterior.
#'
#' This function calculates the posterior distribution give...
#'
#' @param sample_models sample_models
#' @param knots_seq knots_seq
#' @param which_pars which_pars
#' @param post_betas post_betas
#' @param post_gammas post_gammas
#' @param n_pars n_pars
#'
#' @return a cube of posterior draws.
#'
#' @export
smoothing_posterior <- function(sample_models, knots_seq, which_pars, post_betas, post_gammas, U) {
    .Call('_bremory_smoothing_posterior', PACKAGE = 'bremory', sample_models, knots_seq, which_pars, post_betas, post_gammas, U)
}

#' getDraws
#'
#' Function to draw from the posterior distribution (here the second step of drawing from Normal distribution is performed;
#' the first consists in drawing from the multinomial distribution for the Q models)
#'
#' @param sample_models models sample with probabilities given by the specific weighting system used (BIC, pseudoBMA+, stacking, WAIC)
#' @param which_pars which parameters
#' @param n_pars number of parameters per model in the set
#' @param n_stats number of statistics
#' @param input list() of K (number of intervals), gammas (time widths), mle_betas (Maximum Likelihood Estimates), vcov_betas (variance and covariance matrix)
#' @param knots_seq sequence of time widths at which compute the posterior distribution
#'
#' @return matrix.
#'
#' @export
getDraws <- function(sample_models, which_pars, n_pars, n_stats, input, knots_seq) {
    .Call('_bremory_getDraws', PACKAGE = 'bremory', sample_models, which_pars, n_pars, n_stats, input, knots_seq)
}

#' tryClone
#'
#' @param input
#'
#' @return input [dataframe]
#'
#' @export
tryClone <- function(input) {
    .Call('_bremory_tryClone', PACKAGE = 'bremory', input)
}

#' stepwise 
#'
#' @param x transpired time
#' @param pars is the matrix of (betas,widths)
#'
#' @export
stepwiseWeight <- function(x, pars) {
    .Call('_bremory_stepwiseWeight', PACKAGE = 'bremory', x, pars)
}

#' linearWeight 
#'
#' @param x transpired time
#' @param pars is the vector with order (alpha,psi) with alpha in (0,Inf) and psi in (0,Inf) 
#'
#' @export
linearWeight <- function(x, pars) {
    .Call('_bremory_linearWeight', PACKAGE = 'bremory', x, pars)
}

#' twoStepsWeight 
#'
#' @param x transpired time
#' @param pars is the vector of parameters OLD=(shape,scale,psi,phi,shape,scale), (shape1,scale1,psi,phi,x0,shape2,scale2)
#'
#' @export
twoStepsWeight <- function(x, pars) {
    .Call('_bremory_twoStepsWeight', PACKAGE = 'bremory', x, pars)
}

#' weibullWeight (it can be either exponential of a smoothed single-step decrease)
#'
#' @param x transpired time
#' @param pars is the vector with order (shape, scale, psi) 
#'
#' @export
weibullWeight <- function(x, pars) {
    .Call('_bremory_weibullWeight', PACKAGE = 'bremory', x, pars)
}

#' halflifeWeight
#'
#' @param x transpired time
#' @param pars is a column vector with the halflife
#'
#' @export
halflifeWeight <- function(x, pars) {
    .Call('_bremory_halflifeWeight', PACKAGE = 'bremory', x, pars)
}

#' tmaxWeight
#'
#' @param x transpired time
#' @param pars is the matrix of dim 1x1 with the time threshold
#'
#' @export
tmaxWeight <- function(x, pars) {
    .Call('_bremory_tmaxWeight', PACKAGE = 'bremory', x, pars)
}

#' decay (function that calculates the decay according)
#'
#' @param type string defining the type of decay
#' @param x elapsed time of interest
#' @param pars is the vector with order 
#'
#' @export
decay <- function(type, x, pars) {
    .Call('_bremory_decay', PACKAGE = 'bremory', type, x, pars)
}

