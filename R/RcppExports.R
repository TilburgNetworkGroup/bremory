# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' getExogenousVariablesArray
#'
#' @param exos vector of exogenous variables in the linear predictor (we avoid to process statistics that are not specified in the linear predictor but provided in 'data')
#' @param data list of exogenous variables (dyadic and actor variables), with actor/type names converted to ID's according to reh object
#' @param reh  reh object obtained from remify::reh(). It is one of the input arguments needed by bremory::smm()
#'
#' @return list of arrays of 3 dimensions: reh$M rows (number of events in the sequence), reh$D columns (number of dyads at risk in the network), reh$S slices (number of exogenous statistics). No interactions are accounted for at this stage.
#'
#' @export
getExogenousVariablesArray <- function(exos, data, reh) {
    .Call(`_bremory_getExogenousVariablesArray`, exos, data, reh)
}

#' getBinaryREH
#'
#' @param dyad vector of dyad occurred (reh$edgelist[,2])
#' @param D numbr of possible dyads (reh$D)
#'
#' @return matrix with dimensions given by the number of events (by row) and the dimension of the risk set (by column) .
#'
#' @export
getBinaryREH <- function(dyad, D) {
    .Call(`_bremory_getBinaryREH`, dyad, D)
}

#' getIntervals
#'
#' given vectors of widths and time, the function returns.
#'
#' @param env  is the global environment
#' @param widths time lengths of intervals as to the stepwise model
#' @param time vector of time points
#' @param M number of events
#' @param K_q number of steps for the q-th model
#' @param ncores number of ncores
#'
#' @return matrix.
#'
#' @export
getIntervals <- function(env, widths, time, M, K_q, ncores) {
    invisible(.Call(`_bremory_getIntervals`, env, widths, time, M, K_q, ncores))
}

#' getCountsOMP_old
#'
#' @param binaryREH matrix
#' @param lbs_ubs matrix of lower bounds (lb's, first column) and upper bounds (ub's, second column) of binaryREH
#' @param ncores ncores
#'
#' @return matrix of accumulated counts within ranges of binaryREH
#'
#' @export
getCountsOMP_old <- function(binaryREH, lbs_ubs, ncores) {
    .Call(`_bremory_getCountsOMP_old`, binaryREH, lbs_ubs, ncores)
}

#' getCounts
#'
#' @param dyad is the vector of observed dyads 
#' @param D is the number of dyads
#' @param lbs_ubs matrix of lower bounds (lb's, first column) and upper bounds (ub's, second column) of binaryREH
#' @param ncores ncores
#'
#' @return matrix of accumulated counts within ranges of binaryREH
#'
#' @export
getCounts <- function(dyad, D, lbs_ubs, ncores) {
    .Call(`_bremory_getCounts`, dyad, D, lbs_ubs, ncores)
}

#' getCountsIndex (function useful for statistics computation)
#'
#' @param intervals matrix of intervals (non-unique intervals, first two columns are lower bound and upper bound respectively)
#' @param counts matrix of intervals (first two columns are lower bound and upper bound respectively)
#' @param ncores number of ncores
#'
#' @return vector of row indices relative to the matrix 'counts'
#'
#' @export
getCountsIndex <- function(intervals, counts, ncores) {
    .Call(`_bremory_getCountsIndex`, intervals, counts, ncores)
}

#' getIntervalStatistics
#'
#' @param stats is a list of statistics (exogenous and endogenous) which will be updated with the endogenous statistics
#' @param counts matrix of dyad counts for unique intervals
#' @param intervals matrix with all intervals
#' @param actor1 time-ordered sequence of actor1 ID's
#' @param actor2 time-ordered sequence of actor2 ID's
#' @param time vector of time
#' @param M number of events
#' @param N number of actors
#' @param D number of dyads (no event type)
#' @param K number of intervals (q-th model)
#' @param statistics string vector of endogenous statistics
#' @param model 'tie' or 'actor'
#' @param senderRate true/false for actor-oriented modeling. if true, then statistics for sender-rate model, otherwise statistics for the receiver-choice model 
#' @param ncores number of ncores to create in case of parallelization
#'
#' @return list of (interval) statistics
#'
getIntervalStatistics <- function(env, counts, intervals, actor1, actor2, time, M, N, D, K, statistics, model, senderRate = FALSE, ncores = 1L) {
    invisible(.Call(`_bremory_getIntervalStatistics`, env, counts, intervals, actor1, actor2, time, M, N, D, K, statistics, model, senderRate, ncores))
}

#' arrangeStatistics
#'
#' @param env global environment where the environment of statistics is ('stats')
#' @param effectsMatrix is a matrix of effects from the processed formula object
#' @param names is the vector of row names from the matrix of effects (effectsMatrix)
#' @param intercept is a TRUE/FALSE value whether the intercept is specified or not
#' @param M is the number of events
#' @param D is the number of dyads (without event type)
#' @param S is the final number of predictors in the model
#'
#' @return three dimensional array of statistics and vector of names (slices)
#'
arrangeStatistics <- function(env, effectsMatrix, names, intercept, M, D, S) {
    .Call(`_bremory_arrangeStatistics`, env, effectsMatrix, names, intercept, M, D, S)
}

#' getStatisticsNames
#'
#' @param stats_names is a (names) list of vectors of names of statistics
#' @param effectsMatrix is a matrix of effects from the processed formula object
#' @param names is the vector of row names from the matrix of effects (effectsMatrix)
#' @param intercept is a TRUE/FALSE value whether the intercept is specified or not
#' @param M is the number of events
#' @param D is the number of dyads (without event type)
#' @param S is the final number of predictors in the model
#'
#' @return three dimensional array of statistics and vector of names (slices)
#'
#' @export
getStatisticsNames <- function(stats_names, effectsMatrix, names, intercept, M, D, S) {
    .Call(`_bremory_getStatisticsNames`, stats_names, effectsMatrix, names, intercept, M, D, S)
}

#' lpd (Log-Pointwise Density of REM)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
lpd <- function(pars, stats, event, interevent_time) {
    .Call(`_bremory_lpd`, pars, stats, event, interevent_time)
}

#' getWAIC
#'
#' @param pars parameters values
#' @param stats sub-array of statistics
#' @param events sub-matirx of events
#' @param interevent_time sub-vector of interevent times
#'
#' @return matrix of p_m and lpd_m values for a specific stepwise model
#'
#' @export
getWAIC <- function(pars, stats, events, interevent_time) {
    .Call(`_bremory_getWAIC`, pars, stats, events, interevent_time)
}

#' smoothing posterior.
#'
#' This function calculates the posterior distribution give...
#'
#' @param sample_models sample_models
#' @param knots_seq knots_seq
#' @param which_pars which_pars
#' @param post_betas post_betas
#' @param post_gammas post_gammas
#' @param U n_pars
#'
#' @return a cube of posterior draws.
#'
#' @export
smoothing_posterior <- function(sample_models, knots_seq, which_pars, post_betas, post_gammas, U) {
    .Call(`_bremory_smoothing_posterior`, sample_models, knots_seq, which_pars, post_betas, post_gammas, U)
}

#' getDraws
#'
#' Function to draw from the posterior distribution (here the second step of drawing from Normal distribution is performed;
#' the first consists in drawing from the multinomial distribution for the Q models)
#'
#' @param sample_models models sample with probabilities given by the specific weighting system used (BIC, pseudoBMA+, stacking, WAIC)
#' @param which_pars which parameters
#' @param n_pars number of parameters per model in the set
#' @param n_stats number of statistics
#' @param input list() of K (number of intervals), gammas (time widths), mle_betas (Maximum Likelihood Estimates), vcov_betas (variance and covariance matrix)
#' @param knots_seq sequence of time widths at which compute the posterior distribution
#'
#' @return matrix.
#'
#' @export
getDraws <- function(sample_models, which_pars, n_pars, n_stats, input, knots_seq) {
    .Call(`_bremory_getDraws`, sample_models, which_pars, n_pars, n_stats, input, knots_seq)
}

#' tryClone (text here)
#'
#' @param input description of input here
#'
#' @return input [dataframe]
#'
#' @export
tryClone <- function(input) {
    .Call(`_bremory_tryClone`, input)
}

