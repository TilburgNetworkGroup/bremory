district_loc <- data[(missing_cases[j,]==1),]$District # Districts for events with j-th case = 1
province_loc <- data[(missing_cases[j,]==1),]$Province # Provinces for events with j-th case = 1
found_coord_loc <- matrix(NA,nrow=length(cities_loc),ncol=length(columns_missing_idx[[j]]))
print("dim_before_loop")
print(dim(found_coord_loc))
for(i in 1:length(cities_loc)){
dat_loc <- subset_loc[(subset_loc$City==cities_loc[i] & subset_loc$District==district_loc[i] & subset_loc$Province==province_loc[i]),] # conditioned on having same [City,District,Province]
if(dim(dat_loc)[1]>0)
{
if(length(columns_missing_idx[[j]])==1){
coord_loc <- cbind(unique(na.omit(dat_loc[,columns_missing_idx[[j]]])))
}
else{
coord_loc <- rbind(unique(na.omit(dat_loc[,columns_missing_idx[[j]]])))
if(dim(coord_loc)[1]==1) coord_loc <- rbind(as.numeric(coord_loc))
}
print("coords are:")
print(coord_loc)
if(dim(coord_loc)[1]==1)
{
print("dim_inside_loop")
print(dim(found_coord_loc))
#print(dim(dat_loc))
#print(length(cities_loc))
#print(cities_loc[i])
#print(district_loc[i])
#print(province_loc[i])
#print("::end")
print(i)
print(found_coord_loc[i,])
found_coord_loc[i,] <- coord_loc
print("after storing info:")
print(coord_loc)
}
}
}
data[(missing_cases[j,]==1),columns_missing_idx[[j]]] <- found_coord_loc
}
return(data)
}
India <- self_enrichment_data(data = India)
India <- India_old
conditions_freq(data = India)
# the initial output should be the following:
# NA.lat  NA.long NA.both
#     861    1181      87
# (1) self-enrichment from the data
# The first type of enrichment follows the order City --> District --> Province, that is, from the more specific spatial information (City) to the less specific one (Province)
self_enrichment_data <- function(data){
# ... first stage ...
field <- c("City","District","Province")
conditions_before <- conditions_freq(data = data)
conditions_after <- rep(0,3)
while(sum(conditions_before-conditions_after)>0){
conditions_before <- conditions_freq(data = data)
for(k in 1:3){
field_freq <- table(data[,field[k]]) # table of j-th field in the dataset
names_field <- names(field_freq) # saving only the names
for(i in 1:length(names_field)){ # for each name we try to complete [latitude,longitude] for all those events that occurred in the same location and share at least one of the two coordinates.
field_i <- names_field[i]
lat_long_i <- data[data[,field[k]]==field_i,c(19,20)] # latitude and longitude of location i (with missing values as well)
dict_i <- rbind(unique(na.omit(lat_long_i))) # dictionary of spatial coordinates (only the complete combinations of latitude and longitude)
if(dim(dict_i)[1]>0){ # only if the dictionary has at least one combination of [latitude,longitude]
for(j in 1:dim(lat_long_i)[1]){ # only for those events with the same location
if((is.na(lat_long_i[j,1]) & !is.na(lat_long_i[j,2]))){ # if latitude is NA and longitude is known
c_j <- which(dict_i[,2]==lat_long_i[j,2]) # consider events only with the same longitude
if(length(c_j)==1) lat_long_i[j,1] <- dict_i[c_j,1] # if the event has indeed the same longitude, then assign the missing latitude
}
if((!is.na(lat_long_i[j,1]) & is.na(lat_long_i[j,2]))){ # if latitude is known and longitude is NA
c_j <- which(dict_i[,1]==lat_long_i[j,1]) # consider only events with the same latitude
if(length(c_j)==1) lat_long_i[j,2] <- dict_i[c_j,2] # if the event has indeed the same latitude, the assign the missing longitude
}
}
data[data[,field[k]]==field_i,c(19,20)] <- lat_long_i # re-assign [latitude,longitude] matrix, this time having as less missing values as possible
}
}
rm(field_freq,names_field,dict_i,lat_long_i,c_j,field_i,i,j)
}
conditions_after <- conditions_freq(data = data)
}
# ... second stage ...
# Now that we have enriched the spatial coordinates from the dataset (with the first stage) we can perform a further enrichment considering the following matrix output
missing_cases <- apply(data,1,function(x)
{out <- numeric(3)
if(is.na(x[19]) & !is.na(x[20])) out[1] <- 1 # case 1: only Longitude is known (19-th column is Latitude, 20th column is Longitude)
if(is.na(x[20]) & !is.na(x[19])) out[2] <- 1 # case 2: only Latitude is known
if(is.na(x[20]) & is.na(x[19])) out[3] <- 1 # case 3: both Latitude and Longitude are unkwnown
return(out)}
)
columns_missing_idx <- list(19,20,c(19,20)) # for each case the index (or indices) of the missing column(s)
columns_not_missing_idx <- list(20,19)
for(j in 1:3){ # for each case [1,2,3]
subset_loc <-  data[!(missing_cases[j,]==1),] # all the events but those where the j-th case is defined (1)
cities_loc <- data[(missing_cases[j,]==1),]$City # Cities for events with j-th case = 1
district_loc <- data[(missing_cases[j,]==1),]$District # Districts for events with j-th case = 1
province_loc <- data[(missing_cases[j,]==1),]$Province # Provinces for events with j-th case = 1
found_coord_loc <- matrix(NA,nrow=length(cities_loc),ncol=length(columns_missing_idx[[j]]))
for(i in 1:length(cities_loc)){
dat_loc <- subset_loc[(subset_loc$City==cities_loc[i] & subset_loc$District==district_loc[i] & subset_loc$Province==province_loc[i]),] # conditioned on having same [City,District,Province]
if(dim(dat_loc)[1]>0)
{
if(length(columns_missing_idx[[j]])==1){
coord_loc <- cbind(unique(na.omit(dat_loc[,columns_missing_idx[[j]]])))
}
else{
coord_loc <- rbind(unique(na.omit(dat_loc[,columns_missing_idx[[j]]])))
if(dim(coord_loc)[1]==1) coord_loc <- rbind(as.numeric(coord_loc))
}
if(dim(coord_loc)[1]==1)
{
found_coord_loc[i,] <- coord_loc
}
}
}
data[(missing_cases[j,]==1),columns_missing_idx[[j]]] <- found_coord_loc
}
return(data)
}
India <- self_enrichment_data(data = India)
# run conditions_freq()
conditions_freq(data = India)
# NA.lat NA.long NA.both
#     49      61      21
spatial_coordinates_131 <- read.csv('spatial_coordinates_131.csv')
# Find the matrix where by row we now which condition the event reflects. ( [0,0,0] if none of the three conditions are met, thus the event has both latitude and longitude).
missing_cases <- apply(India,1,function(x)
{out <- numeric(3)
if(is.na(x[19]) & !is.na(x[20])) out[1] <- 1 # 19-th column is Latitude, 20th column is Longitude
if(is.na(x[20]) & !is.na(x[19])) out[2] <- 1
if(is.na(x[20]) & is.na(x[19])) out[3] <- 1
return(out)}
)
# Fill Latitude and Longitude with the spatial coordinates in the csv file
India[apply(missing_cases,2,sum)>0,c(19,20)] <- spatial_coordinates_131[,c(3,4)]
# Check conditions_freq()
conditions_freq(data = India) #NA_freq()
# NA.lat NA.long NA.both
#      0       0       0
# Function that finds (potential) duplicates
events_to_omit_fun <- function(data){
freq_dates <- table(data$Event.Date)
dates_unique <- names(freq_dates)
events_to_omit <- freq_omit <- NULL
for(j in 1:length(dates_unique)){
if(freq_dates[j]>1){
data_loc <- data[data$Event.Date == dates_unique[j],]
dyads_loc <- paste(data_loc$Source.Name,data_loc$Target.Name,data_loc$Latitude,data_loc$Longitude,sep="_")
freq_events <- table(dyads_loc)
dyads_events <- names(freq_events)
for(i in 1:length(dyads_events)){
if(freq_events[i]>1){
events_ID <- (data_loc[which(dyads_loc==dyads_events[i]),]$Event.ID)[-1] # we leave one event and omit the rest, thus we exclude one ID from the omission
events_to_omit <- c(events_to_omit,events_ID)
freq_omit <- c(freq_omit,length(events_ID))
}
}
}
}
cat(sum(freq_omit),'events are duplicate to be removed.\n') # sum(freq_omit) should be 1361
return(events_to_omit)
}
events_to_omit <- events_to_omit_fun(data = India)
India <- India[-which(India$Event.ID %in% events_to_omit),] # dim(India) should be nrows = 24300, ncols = 20
# create actors vector (sorted)
actors <- sort(unique(c(India$Source.Name,India$Target.Name))) # 824 actors interacted between 05/1995 and 04/2020
# select network with 40 most active actors
actors40 <- names(sort(table(c(India$Source.Name,India$Target.Name)),decreasing = TRUE)[1:40])
India <- India[which(India$Source.Name %in% actors40 & India$Target.Name %in% actors40),]
# merging actors (see csv file)
# ... change Source.Name's
India$Source.Name[India$Source.Name %in% c("Citizen (India)","Children (India)","Women (India)","Men (India)")] <- "Citizen"
India$Source.Name[India$Source.Name %in% c("Government (India)","Governor (India)","Cabinet / Council of Ministers / Advisors (India)","Head of Government (India)")] <- "Government"
India$Source.Name[India$Source.Name %in% c("Central Bureau of Investigation",
"Police (India)")] <- "Police"
India$Source.Name[India$Source.Name %in% c("Member of the Judiciary (India)","Court Judge (India)")] <- "Member of the Judiciary"
India$Source.Name[India$Source.Name %in% c("Congress (India)","Congress Party")] <- "Indian National Congress"
India$Source.Name[India$Source.Name %in% c("Education (India)","Student (India)")] <- "Education"
India$Source.Name <- sapply(India$Source.Name, function(x) gsub("\\s+\\([^()]*\\)", "", x)) # removing ' (India)'
# ... change Target.Name's
India$Target.Name[India$Target.Name %in% c("Citizen (India)","Children (India)","Women (India)","Men (India)")] <- "Citizen"
India$Target.Name[India$Target.Name %in% c("Government (India)","Governor (India)","Cabinet / Council of Ministers / Advisors (India)","Head of Government (India)")] <- "Government"
India$Target.Name[India$Target.Name %in% c("Central Bureau of Investigation",
"Police (India)")] <- "Police"
India$Target.Name[India$Target.Name %in% c("Member of the Judiciary (India)","Court Judge (India)")] <- "Member of the Judiciary"
India$Target.Name[India$Target.Name %in% c("Congress (India)","Congress Party")] <- "Indian National Congress"
India$Target.Name[India$Target.Name %in% c("Education (India)","Student (India)")] <- "Education"
India$Target.Name <- sapply(India$Target.Name, function(x) gsub("\\s+\\([^()]*\\)", "", x)) # removing ' (India)'
# ... change Source.Name's and Target.Name's of reported political figures
politician_name <- list()
politician_name$'Arvind Kejriwal' <- rbind(c("2013-06-03","2013-12-27","Party Member"),
c("2013-12-28","2014-02-14","Government"),
c("2014-02-15","2015-02-13","Party Member"),
c("2015-02-14","2020-02-06","Government"))
politician_name$'Atal Bihari Vajpayee' <- rbind(c("1997-06-13","1998-03-18","Member of Parliament"),
c("1998-03-19","2004-05-21","Government"),
c("2004-05-22","2019-02-20","Member of Parliament"))
politician_name$'Narendra Modi' <- rbind(c("1999-09-18","2001-10-07", "Party Member"), #note: in reality there exists just one event occurred in 1999-09-18
c("2001-10-09","2014-05-22","Government"),
c("2014-05-24","2020-04-14","Government"))
politician_name$'Manmohan Singh' <- rbind(c("1995-09-07","1996-05-15","Ministry"),
c("1998-03-21","2004-05-21","Member of Parliament"),
c("2004-05-22","2014-05-25","Government"),
c("2014-05-26","2020-02-18","Member of Parliament"))
politician_name$'Rahul Gandhi' <- rbind(c("2014-01-01","2017-12-15","Indian National Congress"),
c("2017-12-16","2019-08-10","Indian National Congress"),
c("2019-08-11","2020-04-14","Member of Parliament"))
politician_name$'Sonia Ghandi' <- rbind(c("1997-11-12","2017-12-16","Indian National Congress"),
c("2018-04-16","2020-04-25","Indian National Congress"))
for(politician in names(politician_name))
{
periods_loc <- politician_name[[politician]]
P <- dim(periods_loc)[1]
for(p in 1:P){
source_loc <- India[which((India$Source.Name == politician) & (India$Event.Date>=periods_loc[p,1] & India$Event.Date<=periods_loc[p,2])),]$Source.Name
if(length(source_loc)>0)
{India[which((India$Source.Name == politician) & (India$Event.Date>=periods_loc[p,1] & India$Event.Date<=periods_loc[p,2])),]$Source.Name  <- rep(periods_loc[p,3],length(source_loc))}
target_loc <- India[which((India$Target.Name == politician) & (India$Event.Date>=periods_loc[p,1] & India$Event.Date<=periods_loc[p,2])),]$Target.Name
if(length(target_loc)>0)
{India[which((India$Target.Name == politician) & (India$Event.Date>=periods_loc[p,1] & India$Event.Date<=periods_loc[p,2])),]$Target.Name <- rep(periods_loc[p,3],length(target_loc))}
}
}
rm(periods_loc,politician_name)
# removing rows (relational events) where the sender and the receiver are coded the same (this can happen when a Head of Government is coded as Government and then interacts with Government)
same_sr <- sapply(1:dim(India)[1],function(x) India$Source.Name[x] == India$Target.Name[x])
India <- India[!same_sr,]
# [...]
# dataset with 10 most active actors
actors10 <- names(sort(table(c(India$Source.Name,India$Target.Name)),decreasing = TRUE)[1:10])
India <- India[which((India$Source.Name %in% actors10) & (India$Target.Name %in% actors10)),]
India <- data.frame(time = India$Event.Date, actor1= India$Source.Name, actor2 = India$Target.Name)
India <- India[India$time>="2012-06-01",] # select only events starting from June 1, 2012
rm(target_loc,source_loc,periods_loc,politician_name,same_sr,actors,actors40)
rm(p,P,politician)
rm(events_to_omit)
rm(missing_cases,spatial_coordinates_131) # clearing space
rm(mprova)
rm(india_old)
rm(India_old)
# libraries to be loaded before the processing:
library(dplyr)
# working directory (EXPLAIN HERE THE DOWNLOAD FROM THE SOURCE)
# setting the working directory where the data files are
setwd("C:\\Users\\Giuseppe\\OneDrive\\Documenti\\Data\\Dataverse\\dataverse_files\\events_per_year")  #change this with user working directory
# saving the names of the data files in a vector
tab_file_names <- list.files()
# loading the first file and selecting only CAMEO.Code = {100,101,102,103,104,105,106,107,108}, which define the event setting "DEMAND" (Event.text == "Demand" (across nations)).
# We also select for Source.Country and Target.Country "India"
India <- read.delim(file=tab_file_names[1], header= TRUE, quote = "")
India <- India %>% filter(CAMEO.Code %in% c(100,101,102,103,104,105,106,107,108) & Source.Country == "India" & Target.Country == "India")
for(i in 2:length(tab_file_names)){ # loading the rest of the files
data_loc <- read.delim(file=tab_file_names[i], header = TRUE, quote = "")
# remove quotation mark for some character columns
for(j in 1:dim(data_loc)[2]){
if(is.character(data_loc[,j])){
data_loc[,j] <- gsub('[\"]','',data_loc[,j])
}
}
data_loc <- data_loc %>% filter(CAMEO.Code %in% c(100,101,102,103,104,105,106,107,108) & Source.Country == "India" & Target.Country == "India")
# uncomment the two lines below if you want to print out file name and dimensions of the dataset
# print(tab_file_names[i])
# print(dim(data_loc))
data_loc$CAMEO.Code <- as.integer(data_loc$CAMEO.Code)
data_loc$Latitude <- as.numeric(data_loc$Latitude)
India <- dplyr::bind_rows(India, data_loc)
rm(data_loc)
}
rm(i,j)
dim(India)
# data should have 25661 observations and 20 variables
# adjusting date variable
date_values <- as.Date(sapply(India$Event.Date, function(x) as.Date.character(x,tryFormats = c("%m/%d/%Y","%Y-%m-%d"))), origin="1970-01-01")
India$Event.Date <- date_values
rm(date_values)
# checking for event_id correspondence with data_package ones (create a .txt file with the event_id of the event history used in the dataset).
# This check can return two outputs:
check_event_id <- function(data,directory = getwd()){
if(!("India_events_id.csv" %in% list.files()))
stop("file 'India_events_id.csv' not found in the working directory")
reference <- read.csv("India_events_id.csv")
setequal_local_reference <- base::setequal(data$Event.ID,reference$event_id)
if(setequal_local_reference)
{
cat("CHECK PASSED! \n")
return(data)
}
else{
setdiff_local_reference <- setdiff(data$Event.ID,reference$event_id)
setdiff_reference_local <- setdiff(reference$event_id,data$Event.ID)
if(length(setdiff_local_reference) > 0){ # local dataset has more events than the reference
cat('The local dataset has more events than the reference. \n')
data <- data[data$Event.ID %in% reference$event_id,]
if(dim(data)[1] < length(reference$event_id))
cat('The subset lead to less events than the number of reference events. Some events in the reference are missing in the local dataset. \n This might lead to a different processed dataset.')
return(data)
}
if(length(setdiff_local_reference) > 0){ # the reference has more event than the local dataset
stop('The reference has more events than the local dataset. Try loading data again. \n')
}
}
}
India <- check_event_id(data  = India)
# Function that returns the number of missing per type:
conditions_freq <- function(data){ # data = data.frame "India"
missing_cases <- apply(data,1,function(x)
{out <- numeric(3)
if(is.na(x[19]) & !is.na(x[20])) out[1] <- 1 # 19-th column is Latitude, 20th column is Longitude
if(is.na(x[20]) & !is.na(x[19])) out[2] <- 1
if(is.na(x[20]) & is.na(x[19])) out[3] <- 1
return(out)}
)
vec_out <- apply(missing_cases,1,sum)
names(vec_out) <- c("NA.lat","NA.long","NA.both")
return(vec_out)
}
conditions_freq(data = India)
# the initial output should be the following:
# NA.lat  NA.long NA.both
#     861    1181      87
rm(check_event_id)
self_enrichment_data <- function(data){
# ... first stage ...
field <- c("City","District","Province")
conditions_before <- conditions_freq(data = data)
conditions_after <- rep(0,3)
while(sum(conditions_before-conditions_after)>0){
conditions_before <- conditions_freq(data = data)
for(k in 1:3){
field_freq <- table(data[,field[k]]) # table of j-th field in the dataset
names_field <- names(field_freq) # saving only the names
for(i in 1:length(names_field)){ # for each name we try to complete [latitude,longitude] for all those events that occurred in the same location and share at least one of the two coordinates.
field_i <- names_field[i]
lat_long_i <- data[data[,field[k]]==field_i,c(19,20)] # latitude and longitude of location i (with missing values as well)
dict_i <- rbind(unique(na.omit(lat_long_i))) # dictionary of spatial coordinates (only the complete combinations of latitude and longitude)
if(dim(dict_i)[1]>0){ # only if the dictionary has at least one combination of [latitude,longitude]
for(j in 1:dim(lat_long_i)[1]){ # only for those events with the same location
if((is.na(lat_long_i[j,1]) & !is.na(lat_long_i[j,2]))){ # if latitude is NA and longitude is known
c_j <- which(dict_i[,2]==lat_long_i[j,2]) # consider events only with the same longitude
if(length(c_j)==1) lat_long_i[j,1] <- dict_i[c_j,1] # if the event has indeed the same longitude, then assign the missing latitude
}
if((!is.na(lat_long_i[j,1]) & is.na(lat_long_i[j,2]))){ # if latitude is known and longitude is NA
c_j <- which(dict_i[,1]==lat_long_i[j,1]) # consider only events with the same latitude
if(length(c_j)==1) lat_long_i[j,2] <- dict_i[c_j,2] # if the event has indeed the same latitude, the assign the missing longitude
}
}
data[data[,field[k]]==field_i,c(19,20)] <- lat_long_i # re-assign [latitude,longitude] matrix, this time having as less missing values as possible
}
}
rm(field_freq,names_field,dict_i,lat_long_i,c_j,field_i,i,j)
}
conditions_after <- conditions_freq(data = data)
}
# ... second stage ...
# Now that we have enriched the spatial coordinates from the dataset (with the first stage) we can perform a further enrichment considering the following matrix output
missing_cases <- apply(data,1,function(x)
{out <- numeric(3)
if(is.na(x[19]) & !is.na(x[20])) out[1] <- 1 # case 1: only Longitude is known (19-th column is Latitude, 20th column is Longitude)
if(is.na(x[20]) & !is.na(x[19])) out[2] <- 1 # case 2: only Latitude is known
if(is.na(x[20]) & is.na(x[19])) out[3] <- 1 # case 3: both Latitude and Longitude are unkwnown
return(out)}
)
columns_missing_idx <- list(19,20,c(19,20)) # for each case the index (or indices) of the missing column(s)
columns_not_missing_idx <- list(20,19)
for(j in 1:3){ # for each case [1,2,3]
subset_loc <-  data[!(missing_cases[j,]==1),] # all the events but those where the j-th case is defined (1)
cities_loc <- data[(missing_cases[j,]==1),]$City # Cities for events with j-th case = 1
district_loc <- data[(missing_cases[j,]==1),]$District # Districts for events with j-th case = 1
province_loc <- data[(missing_cases[j,]==1),]$Province # Provinces for events with j-th case = 1
found_coord_loc <- matrix(NA,nrow=length(cities_loc),ncol=length(columns_missing_idx[[j]]))
for(i in 1:length(cities_loc)){
dat_loc <- subset_loc[(subset_loc$City==cities_loc[i] & subset_loc$District==district_loc[i] & subset_loc$Province==province_loc[i]),] # conditioned on having same [City,District,Province]
if(dim(dat_loc)[1]>0)
{
if(length(columns_missing_idx[[j]])==1){
coord_loc <- cbind(unique(na.omit(dat_loc[,columns_missing_idx[[j]]])))
}
else{
coord_loc <- rbind(unique(na.omit(dat_loc[,columns_missing_idx[[j]]])))
if(dim(coord_loc)[1]==1) coord_loc <- rbind(as.numeric(coord_loc))
}
if(dim(coord_loc)[1]==1)
{
found_coord_loc[i,] <- coord_loc
}
}
}
data[(missing_cases[j,]==1),columns_missing_idx[[j]]] <- found_coord_loc
}
return(data)
}
India <- self_enrichment_data(data = India)
# run conditions_freq()
conditions_freq(data = India)
# NA.lat NA.long NA.both
#     49      61      21
rm(self_enrichment_data)
# loading spatial coordinates
spatial_coordinates_131 <- read.csv('spatial_coordinates_131.csv')
# Find the matrix where by row we now which condition the event reflects. ( [0,0,0] if none of the three conditions are met, thus the event has both latitude and longitude).
missing_cases <- apply(India,1,function(x)
{out <- numeric(3)
if(is.na(x[19]) & !is.na(x[20])) out[1] <- 1 # 19-th column is Latitude, 20th column is Longitude
if(is.na(x[20]) & !is.na(x[19])) out[2] <- 1
if(is.na(x[20]) & is.na(x[19])) out[3] <- 1
return(out)}
)
# Fill Latitude and Longitude with the spatial coordinates in the csv file
India[apply(missing_cases,2,sum)>0,c(19,20)] <- spatial_coordinates_131[,c(3,4)]
rm(missing_cases,spatial_coordinates_131) # clearing space
# Check conditions_freq()
conditions_freq(data = India) #NA_freq()
# NA.lat NA.long NA.both
#      0       0       0
events_to_omit_fun <- function(data){
freq_dates <- table(data$Event.Date)
dates_unique <- names(freq_dates)
events_to_omit <- freq_omit <- NULL
for(j in 1:length(dates_unique)){
if(freq_dates[j]>1){
data_loc <- data[data$Event.Date == dates_unique[j],]
dyads_loc <- paste(data_loc$Source.Name,data_loc$Target.Name,data_loc$Latitude,data_loc$Longitude,sep="_")
freq_events <- table(dyads_loc)
dyads_events <- names(freq_events)
for(i in 1:length(dyads_events)){
if(freq_events[i]>1){
events_ID <- (data_loc[which(dyads_loc==dyads_events[i]),]$Event.ID)[-1] # we leave one event and omit the rest, thus we exclude one ID from the omission
events_to_omit <- c(events_to_omit,events_ID)
freq_omit <- c(freq_omit,length(events_ID))
}
}
}
}
cat(sum(freq_omit),'events are duplicate to be removed.\n') # sum(freq_omit) should be 1361
return(events_to_omit)
}
events_to_omit <- events_to_omit_fun(data = India) # should be 1361 events to be removed
India <- India[-which(India$Event.ID %in% events_to_omit),]
dim(India) # dim(India) should be nrows = 24300, ncols = 20
rm(events_to_omit,events_to_omit_fun)
# create actors vector (sorted)
actors <- sort(unique(c(India$Source.Name,India$Target.Name))) # 824 actors interacted between 05/1995 and 04/2020
# select network with 40 most active actors
actors40 <- names(sort(table(c(India$Source.Name,India$Target.Name)),decreasing = TRUE)[1:40])
India <- India[which(India$Source.Name %in% actors40 & India$Target.Name %in% actors40),]
# ... change Source.Name's
India$Source.Name[India$Source.Name %in% c("Citizen (India)","Children (India)","Women (India)","Men (India)")] <- "Citizen"
India$Source.Name[India$Source.Name %in% c("Government (India)","Governor (India)","Cabinet / Council of Ministers / Advisors (India)","Head of Government (India)")] <- "Government"
India$Source.Name[India$Source.Name %in% c("Central Bureau of Investigation",
"Police (India)")] <- "Police"
India$Source.Name[India$Source.Name %in% c("Member of the Judiciary (India)","Court Judge (India)")] <- "Member of the Judiciary"
India$Source.Name[India$Source.Name %in% c("Congress (India)","Congress Party")] <- "Indian National Congress"
India$Source.Name[India$Source.Name %in% c("Education (India)","Student (India)")] <- "Education"
India$Source.Name <- sapply(India$Source.Name, function(x) gsub("\\s+\\([^()]*\\)", "", x)) # removing ' (India)'
# ... change Target.Name's
India$Target.Name[India$Target.Name %in% c("Citizen (India)","Children (India)","Women (India)","Men (India)")] <- "Citizen"
India$Target.Name[India$Target.Name %in% c("Government (India)","Governor (India)","Cabinet / Council of Ministers / Advisors (India)","Head of Government (India)")] <- "Government"
India$Target.Name[India$Target.Name %in% c("Central Bureau of Investigation",
"Police (India)")] <- "Police"
India$Target.Name[India$Target.Name %in% c("Member of the Judiciary (India)","Court Judge (India)")] <- "Member of the Judiciary"
India$Target.Name[India$Target.Name %in% c("Congress (India)","Congress Party")] <- "Indian National Congress"
India$Target.Name[India$Target.Name %in% c("Education (India)","Student (India)")] <- "Education"
India$Target.Name <- sapply(India$Target.Name, function(x) gsub("\\s+\\([^()]*\\)", "", x)) # removing ' (India)'
# ... change Source.Name's and Target.Name's of reported political figures
politician_name <- list()
politician_name$'Arvind Kejriwal' <- rbind(c("2013-06-03","2013-12-27","Party Member"),
c("2013-12-28","2014-02-14","Government"),
c("2014-02-15","2015-02-13","Party Member"),
c("2015-02-14","2020-02-06","Government"))
politician_name$'Atal Bihari Vajpayee' <- rbind(c("1997-06-13","1998-03-18","Member of Parliament"),
c("1998-03-19","2004-05-21","Government"),
c("2004-05-22","2019-02-20","Member of Parliament"))
politician_name$'Narendra Modi' <- rbind(c("1999-09-18","2001-10-07", "Party Member"),
c("2001-10-09","2014-05-22","Government"),
c("2014-05-24","2020-04-14","Government"))
politician_name$'Manmohan Singh' <- rbind(c("1995-09-07","1996-05-15","Ministry"),
c("1998-03-21","2004-05-21","Member of Parliament"),
c("2004-05-22","2014-05-25","Government"),
c("2014-05-26","2020-02-18","Member of Parliament"))
politician_name$'Rahul Gandhi' <- rbind(c("2014-01-01","2017-12-15","Indian National Congress"),
c("2017-12-16","2019-08-10","Indian National Congress"),
c("2019-08-11","2020-04-14","Member of Parliament"))
politician_name$'Sonia Ghandi' <- rbind(c("1997-11-12","2017-12-16","Indian National Congress"), # the surname "Ghandi" is mistyped in the original data (if a future correction is done in the raw data, this line should be corrected to the right writing)
c("2018-04-16","2020-04-25","Indian National Congress"))
for(politician in names(politician_name))
{
periods_loc <- politician_name[[politician]]
P <- dim(periods_loc)[1]
for(p in 1:P){
source_loc <- India[which((India$Source.Name == politician) & (India$Event.Date>=periods_loc[p,1] & India$Event.Date<=periods_loc[p,2])),]$Source.Name
if(length(source_loc)>0)
{India[which((India$Source.Name == politician) & (India$Event.Date>=periods_loc[p,1] & India$Event.Date<=periods_loc[p,2])),]$Source.Name  <- rep(periods_loc[p,3],length(source_loc))}
target_loc <- India[which((India$Target.Name == politician) & (India$Event.Date>=periods_loc[p,1] & India$Event.Date<=periods_loc[p,2])),]$Target.Name
if(length(target_loc)>0)
{India[which((India$Target.Name == politician) & (India$Event.Date>=periods_loc[p,1] & India$Event.Date<=periods_loc[p,2])),]$Target.Name <- rep(periods_loc[p,3],length(target_loc))}
}
}
# removing rows (relational events) where the sender and the receiver are coded the same (this can happen when a Head of Government is coded as Government and then interacts with Government)
same_sr <- sapply(1:dim(India)[1],function(x) India$Source.Name[x] == India$Target.Name[x])
India <- India[!same_sr,]
rm(p,P,politician,target_loc,source_loc,periods_loc,politician_name,same_sr,actors,actors40)
# [...]
# dataset with 10 most active actors
actors10 <- names(sort(table(c(India$Source.Name,India$Target.Name)),decreasing = TRUE)[1:10])
India <- India[which((India$Source.Name %in% actors10) & (India$Target.Name %in% actors10)),]
India <- data.frame(time = India$Event.Date, actor1= India$Source.Name, actor2 = India$Target.Name)
India <- India[India$time>="2012-06-01",] # select only events starting from June 1, 2012
save(list=ls(),file="India_DEMAND.RData")
rownames(India)
rownames(India)[7000]
rownames(India) <- 1:dim(India)[1]
rownames(India)[7000]
save(list=ls(),file="India_DEMAND.RData")
library(bremory)
